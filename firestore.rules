rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user is admin of an item
    function isItemAdmin(itemData) {
      return isAuthenticated() && request.auth.uid in itemData.adminIds;
    }
    
    // Helper function to check if user is expert of an item
    function isItemExpert(itemData) {
      return isAuthenticated() && request.auth.uid in itemData.expertIds;
    }
    
    // Helper function to check if user is owner
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Rules for items collection (LEGACY - keep for backward compatibility)
    match /items/{itemId} {
      // Allow read if user is authenticated and is either admin or expert
      allow read: if isAuthenticated() && 
        (request.auth.uid in resource.data.adminIds || 
         request.auth.uid in resource.data.expertIds);
      
      // Allow create if user is authenticated and includes themselves as admin
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.adminIds &&
        request.resource.data.keys().hasAll(['title', 'description', 'type', 'adminIds', 'expertIds', 'consensusThreshold', 'maxRounds', 'currentRound', 'status']);
      
      // Allow update if user is admin of the item
      allow update: if isItemAdmin(resource.data);
      
      // Allow delete if user is admin of the item
      allow delete: if isItemAdmin(resource.data);
    }
    
    // Rules for rounds collection
    match /rounds/{roundId} {
      allow read: if isAuthenticated();
      allow create, update: if isAuthenticated();
      allow delete: if false; // Rounds should not be deleted
    }
    
    // Rules for responses collection (LEGACY)
    match /responses/{responseId} {
      // Experts can create and read their own responses
      allow create: if isAuthenticated() && 
        request.auth.uid == request.resource.data.expertId;
      allow read: if isAuthenticated() && 
        request.auth.uid == resource.data.expertId;
      allow update: if false; // Responses should be immutable
      allow delete: if false; // Responses should not be deleted
    }
    
    // Rules for aggregations collection (read-only for most users)
    match /aggregations/{aggregationId} {
      allow read: if isAuthenticated();
      allow write: if false; // Only cloud functions should write aggregations
    }
    
    // Helper function to check if user is admin of a panel
    function isPanelAdmin(panelData) {
      return isAuthenticated() && request.auth.uid in panelData.adminIds;
    }
    
    // Helper function to check if user is expert in a panel
    function isPanelExpert(panelData) {
      return isAuthenticated() && request.auth.uid in panelData.expertIds;
    }
    
    // NEW TOPICS SYSTEM RULES
    
    // Topics collection
    match /topics/{topicId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && (
        resource.data.createdBy == request.auth.uid || 
        // Allow panel experts to update if they have access to the panel
        exists(/databases/$(database)/documents/panels/$(resource.data.panelId))
      );
      allow delete: if isAuthenticated() && resource.data.createdBy == request.auth.uid;
    }
    
    // Panels collection (UPDATED for new system)
    match /panels/{panelId} {
      // Allow read if user is authenticated
      allow read: if isAuthenticated();
      
      // Allow create if user is authenticated
      allow create: if isAuthenticated();
      
      // Allow update if user is creator or expert in the panel
      allow update: if isAuthenticated() && (
        resource.data.creatorId == request.auth.uid ||
        request.auth.uid in resource.data.expertIds ||
        // Legacy support for adminIds
        (resource.data.keys().hasAny(['adminIds']) && request.auth.uid in resource.data.adminIds)
      );
      
      // Allow delete if user is creator or admin
      allow delete: if isAuthenticated() && (
        resource.data.creatorId == request.auth.uid ||
        (resource.data.keys().hasAny(['adminIds']) && request.auth.uid in resource.data.adminIds)
      );
    }
    
    // Experts collection (UPDATED for new system)
    match /experts/{expertId} {
      // Allow read if user is authenticated
      allow read: if isAuthenticated();
      
      // Allow create if user is authenticated
      allow create: if isAuthenticated();
      
      // Allow update if user invited the expert, is the expert themselves, or email matches
      allow update: if isAuthenticated() && (
        resource.data.invitedBy == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        resource.data.email == request.auth.token.email ||
        // Legacy support for uid field
        (resource.data.keys().hasAny(['uid']) && request.auth.uid == resource.data.uid)
      );
      
      // Allow delete if user invited the expert or legacy uid match
      allow delete: if isAuthenticated() && (
        resource.data.invitedBy == request.auth.uid ||
        (resource.data.keys().hasAny(['uid']) && request.auth.uid == resource.data.uid)
      );
    }
    
    // Feedback collection (NEW)
    match /feedback/{feedbackId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && (
        resource.data.expertId == request.auth.uid ||
        // Only allow voting updates by other users
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['voteCount', 'votedBy', 'updatedAt']))
      );
      allow delete: if isAuthenticated() && resource.data.expertId == request.auth.uid;
    }
    
    // Panel invitations collection (LEGACY - keep for backward compatibility)
    match /panelInvitations/{invitationId} {
      // Allow read if user is authenticated AND either:
      // - User is admin of the panel
      // - User's email matches the invitation email
      // - User created the invitation
      allow read: if isAuthenticated() && (
        (exists(/databases/$(database)/documents/panels/$(resource.data.panelId)) &&
         request.auth.uid in get(/databases/$(database)/documents/panels/$(resource.data.panelId)).data.adminIds) ||
        (request.auth.token.email != null && 
         request.auth.token.email == resource.data.email) ||
        request.auth.uid == resource.data.invitedBy
      );
      
      // Allow create if user is admin of the panel being invited to
      allow create: if isAuthenticated() && 
        exists(/databases/$(database)/documents/panels/$(request.resource.data.panelId)) &&
        request.auth.uid in get(/databases/$(database)/documents/panels/$(request.resource.data.panelId)).data.adminIds;
      
      // Allow update to accept/decline invitation or if user is admin
      allow update: if isAuthenticated() && (
        // Allow accepting/declining your own invitation
        (resource.data.status == 'pending' &&
         request.resource.data.status in ['accepted', 'declined']) ||
        // Allow admins to update invitations (for resending, canceling, etc)
        (exists(/databases/$(database)/documents/panels/$(resource.data.panelId)) &&
         request.auth.uid in get(/databases/$(database)/documents/panels/$(resource.data.panelId)).data.adminIds)
      );
      
      // Allow delete if user is admin of the panel
      allow delete: if isAuthenticated() && 
        exists(/databases/$(database)/documents/panels/$(resource.data.panelId)) &&
        request.auth.uid in get(/databases/$(database)/documents/panels/$(resource.data.panelId)).data.adminIds;
    }
    
    // Users collection (for profile data)
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if false; // Users should not be deleted
    }
    
    // Notifications collection
    match /notifications/{notificationId} {
      // Users can only read their own notifications
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Only allow creation through Cloud Functions or by the system
      // Users should not directly create notifications
      allow create: if false;
      
      // Users can only update their own notifications (to mark as read)
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        // Only allow updating 'read' field and 'updatedAt'
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'updatedAt']) &&
        // Validate the read field is boolean
        request.resource.data.read is bool;
      
      // Users cannot delete notifications
      allow delete: if false;
    }
    
    // Notification preferences collection
    match /notificationPreferences/{userId} {
      // Users can only read their own preferences
      allow read: if isOwner(userId);
      
      // Users can create their own preferences
      allow create: if isOwner(userId) &&
        // Validate required fields
        request.resource.data.keys().hasAll(['userId', 'email', 'emailFrequency', 'topicAssigned', 'newFeedback', 'roundClosed', 'consensusReached']) &&
        // Validate field types
        request.resource.data.email is bool &&
        request.resource.data.emailFrequency in ['immediate', 'daily', 'weekly'] &&
        request.resource.data.topicAssigned is bool &&
        request.resource.data.newFeedback is bool &&
        request.resource.data.roundClosed is bool &&
        request.resource.data.consensusReached is bool;
      
      // Users can update their own preferences
      allow update: if isOwner(userId) &&
        // Validate field types if they're being updated
        (!request.resource.data.keys().hasAny(['email']) || request.resource.data.email is bool) &&
        (!request.resource.data.keys().hasAny(['emailFrequency']) || request.resource.data.emailFrequency in ['immediate', 'daily', 'weekly']) &&
        (!request.resource.data.keys().hasAny(['topicAssigned']) || request.resource.data.topicAssigned is bool) &&
        (!request.resource.data.keys().hasAny(['newFeedback']) || request.resource.data.newFeedback is bool) &&
        (!request.resource.data.keys().hasAny(['roundClosed']) || request.resource.data.roundClosed is bool) &&
        (!request.resource.data.keys().hasAny(['consensusReached']) || request.resource.data.consensusReached is bool);
      
      // Users cannot delete their preferences
      allow delete: if false;
    }
  }
}